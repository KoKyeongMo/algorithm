#1010
#내가 쓴 풀이(틀림)

t = int(input())

for _ in range(t):
    n,m = map(int,input().split())
    count = 0
    sum=0
    sum_list = []
    for i in range(n):
        for j in range(1,m-n+1):
            sum+=j
    sum_list.append(sum)
    
    for k in range(sum_list):
        if sum_list[k] <=m:
            count+=1

#해답

import math

def comb(n, k):
    return math.factorial(n) // (math.factorial(k) * math.factorial(n - k))             #m개의 위치중 n개를 선택하는 경우의수와 같고 이는 조합 C(m,n) = m!/n!*(m-n)!을 구하는것과 같다

T = int(input().strip())
for _ in range(T):
    N, M = map(int, input().split())
    print(comb(M, N))

#단순히 조합론에 대한 공부가 아직 되지않아 풀수없었던 문제


#1978
#내가 쓴 풀이

n = int(input())
count = 0
num_list = list(map(int,input().split()))

for i in num_list:
    while i%2 !=0:
        for j in range(3,i):
            if i%j ==0:
                break
        else:
            count+=1
                
print(count)

#해답

import math

def is_prime(num):
    if num <= 1:
        return False
    for i in range(2, int(math.sqrt(num)) + 1):                   #숫자 n이 소수인지는 n을 2부터 루트n에 이르기까지의 숫자들로 나눠보고 한번도 나머지가 0이되지 않으면 소수 판정을 받음
        if num % i == 0:
            return False
    return True                                                      #return 은 바로 그 값을 반환하고 함수는 그즉시 종료된다

N = int(input())
numbers = list(map(int, input().split()))

prime_count = 0
for number in numbers:
    if is_prime(number):
        prime_count += 1

print(prime_count)


























