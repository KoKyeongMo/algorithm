
10844번 쉬운 계단 수

해석: 각 자리의 0부터 9까지의 경우를 나누어 생각한다. 특정 자리의 각 경우마다 그 앞자리의 +1인수와 -1인수가 각각 가지는 경우를 합한값임을 인지한다. 단 해당 자리의 숫자가 0이나 9일경우 각각 -1과 +1의 경우는 생각할수 없으므로 각각 그 앞자리의 1이었던 경우와 8이었던 경우를 그대로 가져온다.

필요한작업: 먼저 첫번째 자리의 경우의 수를 정해준다. 그 후 자동적으로 경우의 수가 서로 합해질수 있도록 점화식을 세워준다.

주의: if 문을 작성할때 0<j<9같은 식은 통하지 않는다. j>0 && j>9처럼만 적어야 한다. 
      int 변수가 감당할수 있는 최댓값은 약 20억이므로 20억 이상의 값이 예상될경우 long long 으로 선언하도록 하자.
      일일이 1000000000과 같은 수를 여러번 사용해야 할경우 쉽게 매크로를 이용해 #define mod 1000000000 처럼 나타내자.

#include <iostream>
#define num 1000000000
using namespace std;
int main(){
    ios::sync_with_stdio(0); cin.tie(0);
    int n, i,j;
    long long a[110][11]={0};
    long long sum=0;
    cin>>n;
    for (i=1;i<=9;i++){
        a[1][i] = 1;
    }
    for(i=2;i<=n;i++){
        for(j=0;j<=9;j++){
            if (j>0 && j<9)
            a[i][j] = (a[i-1][j-1] + a[i-1][j+1])%num;
            else if (j==0) a[i][j] = a[i-1][j+1]%num;
            else if (j==9) a[i][j] = a[i-1][j-1]%num;
        }
    }
    for(i=0;i<=9;i++){
        sum += a[n][i];
    }
    cout<<sum%num;
}

2579번 계단 오르기

#include <iostream>
#include <vector>
#include <algorithm>
#include <string>

using namespace std;

int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	int n;
	int es[301];
	int dp[301];
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> es[i];
	}
	dp[1] = es[1];
	dp[2] = es[1] + es[2];
	dp[3] = max(es[1] + es[3], es[2] + es[3]);
	for (int i = 4; i <= n; i++) {
		dp[i] = max(dp[i - 2] + es[i], dp[i - 3] + es[i - 1] + es[i]);
	}
	cout << dp[n];
}

해결법 :
동적 계획법을 풀때는 dp[] 배열을 만들고 점화식을 찾아내어 dp를 이용한 점화식을 만들생각을 해야됨. 

17626번 Four Squares

#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <unordered_map>

using namespace std;

int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int n;
	cin >> n;
	int dp[50001] = { 0 };

	for (int i = 1; i*i<=n; i++) {
		dp[i * i] = 1;
	}

	for (int i = 2; i <= n; i++) {
		int min=10000;
		if (dp[i] == 1) {
			continue;
		}
		for (int j = 1; j <= sqrt(i); j++) {
			int tp = dp[j*j] + dp[i - j*j];
			if (min>tp) {
				min = tp;
			}
		}
		dp[i] = min;
	}
	cout << dp[n];

}

해결법 : 
각 i 마다 최소 몇개의 제곱수 합으로 나타나지는지를 dp값으로 둔다. 즉 모든 제곱수는 dp를 1로 설정, 나머지 i 들의 dp는 dp[제곱수] + dp[i-제곱수] 의 경우들중에 가장 작은 경우를 따지면 된다.


